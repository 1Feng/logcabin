import sys
import os

opts = Variables('Local.sc')

opts.AddVariables(
    ("CC", "C Compiler"),
    ("CPPPATH", "The list of directories that the C preprocessor "
                "will search for include directories", []),
    ("CXX", "C++ Compiler"),
    ("CXXFLAGS", "Options that are passed to the C++ compiler", []),
    ("LINKFLAGS", "Options that are passed to the linker", []),
    ("AS", "Assembler"),
    ("LIBPATH", "Library paths that are passed to the linker", []),
    ("LINK", "Linker"),
    ("BUILDTYPE", "Build type (RELEASE or DEBUG)", "DEBUG"),
    ("VERBOSE", "Show full build information (0 or 1)", "0"),
    ("NUMCPUS", "Number of CPUs to use for build (0 means auto).", "0"),
)

env = Environment(options = opts,
                  tools = ['default', 'protoc', 'packaging'],
                  ENV = os.environ)
Help(opts.GenerateHelpText(env))

env.Prepend(CXXFLAGS = [
    "-std=c++0x",
    "-Wall",
    "-Wextra",
    "-Wcast-align",
    "-Wcast-qual",
    "-Wconversion",
    "-Weffc++",
    "-Wformat=2",
    "-Wmissing-format-attribute",
    "-Wno-non-template-friend",
    "-Wno-unused-parameter",
    "-Woverloaded-virtual",
    "-Wwrite-strings",
    "-DSWIG", # For some unknown reason, this suppresses some definitions in
              # headers generated by protobuf 1.6 (but not 1.5) that we don't
              # use and that cause warnings with -Weffc++.
    ])

if env["BUILDTYPE"] == "DEBUG":
    env.Append(CPPFLAGS = [ "-g", "-DDEBUG" ])
elif env["BUILDTYPE"] == "RELEASE":
    env.Append(CPPFLAGS = [ "-DNDEBUG", "-O2" ])
else:
    print "Error BUILDTYPE must be RELEASE or DEBUG"
    sys.exit(-1)

if env["VERBOSE"] == "0":
    env["CCCOMSTR"] = "Compiling $SOURCE"
    env["CXXCOMSTR"] = "Compiling $SOURCE"
    env["SHCCCOMSTR"] = "Compiling $SOURCE"
    env["SHCXXCOMSTR"] = "Compiling $SOURCE"
    env["ARCOMSTR"] = "Creating library $TARGET"
    env["LINKCOMSTR"] = "Linking $TARGET"

env.Append(CPPPATH = '#')
env.Append(CPPPATH = '#/include')

# Define protocol buffers builder to simplify SConstruct files
def Protobuf(env, source):
    # First build the proto file
    cc = env.Protoc(os.path.splitext(source)[0] + '.pb.cc',
                    source,
                    PROTOCPROTOPATH = ["."],
                    PROTOCPYTHONOUTDIR = ".",
                    PROTOCOUTDIR = ".")[1]
    # Then build the resulting C++ file with no warnings
    return env.StaticObject(cc,
                            CXXFLAGS = "-std=c++0x -Ibuild")
env.AddMethod(Protobuf)

def GetNumCPUs():
    if env["NUMCPUS"] != "0":
        return int(env["NUMCPUS"])
    if os.sysconf_names.has_key("SC_NPROCESSORS_ONLN"):
        cpus = os.sysconf("SC_NPROCESSORS_ONLN")
        if isinstance(cpus, int) and cpus > 0:
            return 2*cpus
        else:
            return 2
    return 2*int(os.popen2("sysctl -n hw.ncpu")[1].read())

env.SetOption('num_jobs', GetNumCPUs())

object_files = {}
Export('object_files')

Export('env')
SConscript('Core/SConscript', variant_dir='build/Core')
SConscript('Event/SConscript', variant_dir='build/Event')
SConscript('RPC/SConscript', variant_dir='build/RPC')
SConscript('Protocol/SConscript', variant_dir='build/Protocol')
SConscript('Tree/SConscript', variant_dir='build/Tree')
SConscript('Client/SConscript', variant_dir='build/Client')
SConscript('Storage/SConscript', variant_dir='build/Storage')
SConscript('Server/SConscript', variant_dir='build/Server')
SConscript('test/SConscript', variant_dir='build/test')
SConscript('Examples/SConscript', variant_dir='build/Examples')

# This function is taken from http://www.scons.org/wiki/PhonyTargets
def PhonyTargets(env = None, **kw):
    if not env: env = DefaultEnvironment()
    for target,action in kw.items():
        env.AlwaysBuild(env.Alias(target, [], action))

PhonyTargets(check = "scripts/cpplint.py")
PhonyTargets(lint = "scripts/cpplint.py")
PhonyTargets(doc = "doxygen docs/Doxyfile")
PhonyTargets(docs = "doxygen docs/Doxyfile")
PhonyTargets(tags = "ctags -R --exclude=build --exclude=docs .")

env.StaticLibrary("build/logcabin",
                  (object_files['Client'] +
                   object_files['Tree'] +
                   object_files['Protocol'] +
                   object_files['RPC'] +
                   object_files['Event'] +
                   object_files['Core']))

env.Program("build/LogCabin",
            (["build/Server/Main.cc"] +
             object_files['Server'] +
             object_files['Storage'] +
             object_files['Tree'] +
             object_files['Protocol'] +
             object_files['RPC'] +
             object_files['Event'] +
             object_files['Core']),
            LIBS = [ "pthread", "protobuf", "rt", "cryptopp" ])

# this will add the files section to the spec file
env.InstallAs(target='/usr/sbin/logcabin', source='build/LogCabin')
env.InstallAs('/etc/init.d/logcabin', 'scripts/logcabin')
env.InstallAs('/usr/bin/Benchmark', 'build/Examples/Benchmark')
env.InstallAs('/usr/bin/DumpTree', 'build/Examples/DumpTree')
env.InstallAs('/usr/bin/SmokeTest', 'build/Examples/SmokeTest')
env.InstallAs('/usr/bin/ServerStats', 'build/Examples/ServerStats')
env.InstallAs('/usr/bin/Reconfigure', 'build/Examples/Reconfigure')
env.InstallAs('/usr/bin/HelloWorld', 'build/Examples/HelloWorld')

# http://scons.tigris.org/ds/viewMessage.do?dsForumId=1272&dsMessageId=923496
#
# having trouble getting this rpm packager to function. it doesn't
# seem to be understanding the dependencies correctly, so going to
# over cheat just to get something working
#
#for root, dirs, files in os.walk("."):
#    path = root.split('/')
#    for file in files:
#        if '.h' in file:
#            env.File(root + file)
# env.File('site_scons/site_tools/protoc.py')
# env.File('Core/Debug.h')
# env.File('Core/ProtoBuf.h')
# env.File('Core/ThreadId.h')
env["X_RPM_INSTALL"] = \
    'mkdir -p $RPM_BUILD_ROOT/usr/sbin\n' \
    'mkdir -p $RPM_BUILD_ROOT/usr/bin\n' \
    'mkdir -p $RPM_BUILD_ROOT/etc/init.d\n' \
    'cp ../../../build/LogCabin $RPM_BUILD_ROOT/usr/sbin/logcabin\n' \
    'cp ../../../build/Examples/Benchmark $RPM_BUILD_ROOT/usr/bin/\n' \
    'cp ../../../build/Examples/DumpTree $RPM_BUILD_ROOT/usr/bin/\n' \
    'cp ../../../build/Examples/SmokeTest $RPM_BUILD_ROOT/usr/bin/\n' \
    'cp ../../../build/Examples/ServerStats $RPM_BUILD_ROOT/usr/bin/\n' \
    'cp ../../../build/Examples/Reconfigure $RPM_BUILD_ROOT/usr/bin/\n' \
    'cp ../../../build/Examples/HelloWorld $RPM_BUILD_ROOT/usr/bin/\n' \
    'cp ../../../scripts/logcabin $RPM_BUILD_ROOT/etc/init.d/logcabin\n'

env.Package(
    NAME           = 'logcabin',
    VERSION        = '0.0.0.1',
    PACKAGEVERSION = 0,
    PACKAGETYPE    = 'rpm',
    LICENSE        = 'stanford',
    SUMMARY        = 'LogCabin is clustered consensus deamon',
    X_RPM_GROUP    = 'Application/logcabin',
    DESCRIPTION    =
    'LogCabin is a distributed system that provides a small amount of\n'
    'highly replicated, consistent storage. It is a reliable place for\n'
    'other distributed systems to store their core metadata and\n'
    'is helpful in solving cluster management issues. Although its key\n'
    'functionality is in place, LogCabin is not yet recommended\n'
    'for actual use.'
)
